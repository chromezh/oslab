// Generated by purs bundle 0.12.1
var PS = {};
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Semigroupoid = function (compose) {
      this.compose = compose;
  };
  var semigroupoidFn = new Semigroupoid(function (f) {
      return function (g) {
          return function (x) {
              return f(g(x));
          };
      };
  });
  var compose = function (dict) {
      return dict.compose;
  };
  exports["compose"] = compose;
  exports["Semigroupoid"] = Semigroupoid;
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS["Control.Semigroupoid"] = PS["Control.Semigroupoid"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Control_Semigroupoid = PS["Control.Semigroupoid"];                 
  var Category = function (Semigroupoid0, identity) {
      this.Semigroupoid0 = Semigroupoid0;
      this.identity = identity;
  };
  var identity = function (dict) {
      return dict.identity;
  };
  var categoryFn = new Category(function () {
      return Control_Semigroupoid.semigroupoidFn;
  }, function (x) {
      return x;
  });
  exports["Category"] = Category;
  exports["identity"] = identity;
  exports["categoryFn"] = categoryFn;
})(PS["Control.Category"] = PS["Control.Category"] || {});
(function(exports) {
    "use strict";

  exports.intSub = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x - y | 0;
    };
  };
})(PS["Data.Ring"] = PS["Data.Ring"] || {});
(function(exports) {
    "use strict";

  exports.intAdd = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x + y | 0;
    };
  };

  exports.intMul = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x * y | 0;
    };
  };
})(PS["Data.Semiring"] = PS["Data.Semiring"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Data.Symbol"];      
  var SProxy = (function () {
      function SProxy() {

      };
      SProxy.value = new SProxy();
      return SProxy;
  })();
  var IsSymbol = function (reflectSymbol) {
      this.reflectSymbol = reflectSymbol;
  };
  var reflectSymbol = function (dict) {
      return dict.reflectSymbol;
  };
  exports["IsSymbol"] = IsSymbol;
  exports["reflectSymbol"] = reflectSymbol;
  exports["SProxy"] = SProxy;
})(PS["Data.Symbol"] = PS["Data.Symbol"] || {});
(function(exports) {
    "use strict";

  exports.unsafeGet = function (label) {
    return function (rec) {
      return rec[label];
    };
  };
})(PS["Record.Unsafe"] = PS["Record.Unsafe"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Record.Unsafe"];
  exports["unsafeGet"] = $foreign.unsafeGet;
})(PS["Record.Unsafe"] = PS["Record.Unsafe"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Data.Semiring"];
  var Data_Symbol = PS["Data.Symbol"];
  var Data_Unit = PS["Data.Unit"];
  var Record_Unsafe = PS["Record.Unsafe"];
  var Type_Data_Row = PS["Type.Data.Row"];
  var Type_Data_RowList = PS["Type.Data.RowList"];                 
  var Semiring = function (add, mul, one, zero) {
      this.add = add;
      this.mul = mul;
      this.one = one;
      this.zero = zero;
  };
  var zero = function (dict) {
      return dict.zero;
  };                                                                            
  var semiringInt = new Semiring($foreign.intAdd, $foreign.intMul, 1, 0);
  var one = function (dict) {
      return dict.one;
  };
  var mul = function (dict) {
      return dict.mul;
  };
  var add = function (dict) {
      return dict.add;
  };
  exports["Semiring"] = Semiring;
  exports["add"] = add;
  exports["zero"] = zero;
  exports["mul"] = mul;
  exports["one"] = one;
  exports["semiringInt"] = semiringInt;
})(PS["Data.Semiring"] = PS["Data.Semiring"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Data.Ring"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Symbol = PS["Data.Symbol"];
  var Data_Unit = PS["Data.Unit"];
  var Record_Unsafe = PS["Record.Unsafe"];
  var Type_Data_RowList = PS["Type.Data.RowList"];                 
  var Ring = function (Semiring0, sub) {
      this.Semiring0 = Semiring0;
      this.sub = sub;
  };
  var sub = function (dict) {
      return dict.sub;
  };                  
  var ringInt = new Ring(function () {
      return Data_Semiring.semiringInt;
  }, $foreign.intSub);
  exports["Ring"] = Ring;
  exports["sub"] = sub;
  exports["ringInt"] = ringInt;
})(PS["Data.Ring"] = PS["Data.Ring"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Control_Category = PS["Control.Category"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };
  var $$const = function (a) {
      return function (v) {
          return a;
      };
  };
  exports["flip"] = flip;
  exports["const"] = $$const;
})(PS["Data.Function"] = PS["Data.Function"] || {});
(function(exports) {
    "use strict";

  exports.arrayMap = function (f) {
    return function (arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];
  var Data_Unit = PS["Data.Unit"];                 
  var Functor = function (map) {
      this.map = map;
  };
  var map = function (dict) {
      return dict.map;
  };
  var functorFn = new Functor(Control_Semigroupoid.compose(Control_Semigroupoid.semigroupoidFn));
  var functorArray = new Functor($foreign.arrayMap);
  exports["Functor"] = Functor;
  exports["map"] = map;
  exports["functorFn"] = functorFn;
  exports["functorArray"] = functorArray;
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];                 
  var Apply = function (Functor0, apply) {
      this.Functor0 = Functor0;
      this.apply = apply;
  };                      
  var apply = function (dict) {
      return dict.apply;
  };
  exports["Apply"] = Apply;
  exports["apply"] = apply;
})(PS["Control.Apply"] = PS["Control.Apply"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Control_Apply = PS["Control.Apply"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];                 
  var Applicative = function (Apply0, pure) {
      this.Apply0 = Apply0;
      this.pure = pure;
  };
  var pure = function (dict) {
      return dict.pure;
  };
  exports["Applicative"] = Applicative;
  exports["pure"] = pure;
})(PS["Control.Applicative"] = PS["Control.Applicative"] || {});
(function(exports) {
    "use strict";

  exports.foldrArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };

  exports.foldlArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
    "use strict";

  exports.boolConj = function (b1) {
    return function (b2) {
      return b1 && b2;
    };
  };

  exports.boolDisj = function (b1) {
    return function (b2) {
      return b1 || b2;
    };
  };

  exports.boolNot = function (b) {
    return !b;
  };
})(PS["Data.HeytingAlgebra"] = PS["Data.HeytingAlgebra"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Data.HeytingAlgebra"];
  var Data_Symbol = PS["Data.Symbol"];
  var Data_Unit = PS["Data.Unit"];
  var Record_Unsafe = PS["Record.Unsafe"];
  var Type_Data_Row = PS["Type.Data.Row"];
  var Type_Data_RowList = PS["Type.Data.RowList"];                 
  var HeytingAlgebra = function (conj, disj, ff, implies, not, tt) {
      this.conj = conj;
      this.disj = disj;
      this.ff = ff;
      this.implies = implies;
      this.not = not;
      this.tt = tt;
  };
  var tt = function (dict) {
      return dict.tt;
  };
  var not = function (dict) {
      return dict.not;
  };
  var implies = function (dict) {
      return dict.implies;
  };
  var ff = function (dict) {
      return dict.ff;
  };
  var disj = function (dict) {
      return dict.disj;
  };
  var heytingAlgebraBoolean = new HeytingAlgebra($foreign.boolConj, $foreign.boolDisj, false, function (a) {
      return function (b) {
          return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);
      };
  }, $foreign.boolNot, true);
  var conj = function (dict) {
      return dict.conj;
  };
  exports["HeytingAlgebra"] = HeytingAlgebra;
  exports["tt"] = tt;
  exports["ff"] = ff;
  exports["implies"] = implies;
  exports["conj"] = conj;
  exports["disj"] = disj;
  exports["not"] = not;
  exports["heytingAlgebraBoolean"] = heytingAlgebraBoolean;
})(PS["Data.HeytingAlgebra"] = PS["Data.HeytingAlgebra"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Data.Semigroup"];
  var Data_Symbol = PS["Data.Symbol"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Void = PS["Data.Void"];
  var Record_Unsafe = PS["Record.Unsafe"];
  var Type_Data_RowList = PS["Type.Data.RowList"];                 
  var Semigroup = function (append) {
      this.append = append;
  };
  var append = function (dict) {
      return dict.append;
  };
  exports["Semigroup"] = Semigroup;
  exports["append"] = append;
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Symbol = PS["Data.Symbol"];
  var Data_Unit = PS["Data.Unit"];
  var Record_Unsafe = PS["Record.Unsafe"];
  var Type_Data_RowList = PS["Type.Data.RowList"];                 
  var Monoid = function (Semigroup0, mempty) {
      this.Semigroup0 = Semigroup0;
      this.mempty = mempty;
  };
  var mempty = function (dict) {
      return dict.mempty;
  };
  exports["Monoid"] = Monoid;
  exports["mempty"] = mempty;
})(PS["Data.Monoid"] = PS["Data.Monoid"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad = PS["Control.Monad"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];                 
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();
  var maybe = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Nothing) {
                  return v;
              };
              if (v2 instanceof Just) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Maybe line 217, column 1 - line 217, column 51: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  var isNothing = maybe(true)(Data_Function["const"](false));
  var functorMaybe = new Data_Functor.Functor(function (v) {
      return function (v1) {
          if (v1 instanceof Just) {
              return new Just(v(v1.value0));
          };
          return Nothing.value;
      };
  });
  var fromMaybe = function (a) {
      return maybe(a)(Control_Category.identity(Control_Category.categoryFn));
  };
  var fromJust = function (dictPartial) {
      return function (v) {
          var $__unused = function (dictPartial1) {
              return function ($dollar35) {
                  return $dollar35;
              };
          };
          return $__unused(dictPartial)((function () {
              if (v instanceof Just) {
                  return v.value0;
              };
              throw new Error("Failed pattern match at Data.Maybe line 268, column 1 - line 268, column 46: " + [ v.constructor.name ]);
          })());
      };
  };
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["maybe"] = maybe;
  exports["fromMaybe"] = fromMaybe;
  exports["isNothing"] = isNothing;
  exports["fromJust"] = fromJust;
  exports["functorMaybe"] = functorMaybe;
})(PS["Data.Maybe"] = PS["Data.Maybe"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Prelude = PS["Prelude"];                 
  var Conj = function (x) {
      return x;
  };
  var semigroupConj = function (dictHeytingAlgebra) {
      return new Data_Semigroup.Semigroup(function (v) {
          return function (v1) {
              return Data_HeytingAlgebra.conj(dictHeytingAlgebra)(v)(v1);
          };
      });
  };
  var monoidConj = function (dictHeytingAlgebra) {
      return new Data_Monoid.Monoid(function () {
          return semigroupConj(dictHeytingAlgebra);
      }, Data_HeytingAlgebra.tt(dictHeytingAlgebra));
  };
  exports["Conj"] = Conj;
  exports["semigroupConj"] = semigroupConj;
  exports["monoidConj"] = monoidConj;
})(PS["Data.Monoid.Conj"] = PS["Data.Monoid.Conj"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Monoid_Additive = PS["Data.Monoid.Additive"];
  var Data_Monoid_Conj = PS["Data.Monoid.Conj"];
  var Data_Monoid_Disj = PS["Data.Monoid.Disj"];
  var Data_Monoid_Dual = PS["Data.Monoid.Dual"];
  var Data_Monoid_Endo = PS["Data.Monoid.Endo"];
  var Data_Monoid_Multiplicative = PS["Data.Monoid.Multiplicative"];
  var Data_Semigroup_First = PS["Data.Semigroup.First"];
  var Data_Semigroup_Last = PS["Data.Semigroup.Last"];
  var Prelude = PS["Prelude"];                 
  var Newtype = function (unwrap, wrap) {
      this.unwrap = unwrap;
      this.wrap = wrap;
  };
  var wrap = function (dict) {
      return dict.wrap;
  };
  var unwrap = function (dict) {
      return dict.unwrap;
  };                        
  var newtypeConj = new Newtype(function (v) {
      return v;
  }, Data_Monoid_Conj.Conj);
  var alaF = function (dictFunctor) {
      return function (dictFunctor1) {
          return function (dictNewtype) {
              return function (dictNewtype1) {
                  return function (v) {
                      return function (f) {
                          return function ($80) {
                              return Data_Functor.map(dictFunctor1)(unwrap(dictNewtype1))(f(Data_Functor.map(dictFunctor)(wrap(dictNewtype))($80)));
                          };
                      };
                  };
              };
          };
      };
  };
  exports["unwrap"] = unwrap;
  exports["wrap"] = wrap;
  exports["Newtype"] = Newtype;
  exports["alaF"] = alaF;
  exports["newtypeConj"] = newtypeConj;
})(PS["Data.Newtype"] = PS["Data.Newtype"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Data.Foldable"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Maybe_Last = PS["Data.Maybe.Last"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Monoid_Additive = PS["Data.Monoid.Additive"];
  var Data_Monoid_Conj = PS["Data.Monoid.Conj"];
  var Data_Monoid_Disj = PS["Data.Monoid.Disj"];
  var Data_Monoid_Dual = PS["Data.Monoid.Dual"];
  var Data_Monoid_Endo = PS["Data.Monoid.Endo"];
  var Data_Monoid_Multiplicative = PS["Data.Monoid.Multiplicative"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];                 
  var Foldable = function (foldMap, foldl, foldr) {
      this.foldMap = foldMap;
      this.foldl = foldl;
      this.foldr = foldr;
  };
  var foldr = function (dict) {
      return dict.foldr;
  };
  var foldl = function (dict) {
      return dict.foldl;
  }; 
  var foldMapDefaultR = function (dictFoldable) {
      return function (dictMonoid) {
          return function (f) {
              return foldr(dictFoldable)(function (x) {
                  return function (acc) {
                      return Data_Semigroup.append(dictMonoid.Semigroup0())(f(x))(acc);
                  };
              })(Data_Monoid.mempty(dictMonoid));
          };
      };
  };
  var foldableArray = new Foldable(function (dictMonoid) {
      return foldMapDefaultR(foldableArray)(dictMonoid);
  }, $foreign.foldlArray, $foreign.foldrArray);
  var foldMap = function (dict) {
      return dict.foldMap;
  };
  var all = function (dictFoldable) {
      return function (dictHeytingAlgebra) {
          return Data_Newtype.alaF(Data_Functor.functorFn)(Data_Functor.functorFn)(Data_Newtype.newtypeConj)(Data_Newtype.newtypeConj)(Data_Monoid_Conj.Conj)(foldMap(dictFoldable)(Data_Monoid_Conj.monoidConj(dictHeytingAlgebra)));
      };
  };
  exports["Foldable"] = Foldable;
  exports["foldr"] = foldr;
  exports["foldl"] = foldl;
  exports["foldMap"] = foldMap;
  exports["foldMapDefaultR"] = foldMapDefaultR;
  exports["all"] = all;
  exports["foldableArray"] = foldableArray;
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
    "use strict";

  exports.fromStringAsImpl = function (just) {
    return function (nothing) {
      return function (radix) {
        var digits;
        if (radix < 11) {
          digits = "[0-" + (radix - 1).toString() + "]";
        } else if (radix === 11) {
          digits = "[0-9a]";
        } else {
          digits = "[0-9a-" + String.fromCharCode(86 + radix) + "]";
        }
        var pattern = new RegExp("^[\\+\\-]?" + digits + "+$", "i");

        return function (s) {
          /* jshint bitwise: false */
          if (pattern.test(s)) {
            var i = parseInt(s, radix);
            return (i | 0) === i ? just(i) : nothing;
          } else {
            return nothing;
          }
        };
      };
    };
  };
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Data.Int"];
  var Control_Category = PS["Control.Category"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_DivisionRing = PS["Data.DivisionRing"];
  var Data_Eq = PS["Data.Eq"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Int_Bits = PS["Data.Int.Bits"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Global = PS["Global"];
  var $$Math = PS["Math"];
  var Prelude = PS["Prelude"];
  var fromStringAs = $foreign.fromStringAsImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var fromString = fromStringAs(10);
  exports["fromString"] = fromString;
  exports["fromStringAs"] = fromStringAs;
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Biapplicative = PS["Control.Biapplicative"];
  var Control_Biapply = PS["Control.Biapply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Bifoldable = PS["Data.Bifoldable"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Bitraversable = PS["Data.Bitraversable"];
  var Data_BooleanAlgebra = PS["Data.BooleanAlgebra"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_Distributive = PS["Data.Distributive"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_FoldableWithIndex = PS["Data.FoldableWithIndex"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_FunctorWithIndex = PS["Data.FunctorWithIndex"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semigroup_Foldable = PS["Data.Semigroup.Foldable"];
  var Data_Semigroup_Traversable = PS["Data.Semigroup.Traversable"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_TraversableWithIndex = PS["Data.TraversableWithIndex"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];
  var Type_Equality = PS["Type.Equality"];                 
  var Tuple = (function () {
      function Tuple(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Tuple.create = function (value0) {
          return function (value1) {
              return new Tuple(value0, value1);
          };
      };
      return Tuple;
  })();
  var snd = function (v) {
      return v.value1;
  };                                                                                                    
  var fst = function (v) {
      return v.value0;
  };
  exports["Tuple"] = Tuple;
  exports["fst"] = fst;
  exports["snd"] = snd;
})(PS["Data.Tuple"] = PS["Data.Tuple"] || {});
(function(exports) {
    "use strict";

  exports.unfoldrArrayImpl = function (isNothing) {
    return function (fromJust) {
      return function (fst) {
        return function (snd) {
          return function (f) {
            return function (b) {
              var result = [];
              var value = b;
              while (true) { // eslint-disable-line no-constant-condition
                var maybe = f(value);
                if (isNothing(maybe)) return result;
                var tuple = fromJust(maybe);
                result.push(fst(tuple));
                value = snd(tuple);
              }
            };
          };
        };
      };
    };
  };
})(PS["Data.Unfoldable"] = PS["Data.Unfoldable"] || {});
(function(exports) {
    "use strict";

  exports.unfoldr1ArrayImpl = function (isNothing) {
    return function (fromJust) {
      return function (fst) {
        return function (snd) {
          return function (f) {
            return function (b) {
              var result = [];
              var value = b;
              while (true) { // eslint-disable-line no-constant-condition
                var tuple = f(value);
                result.push(fst(tuple));
                var maybe = snd(tuple);
                if (isNothing(maybe)) return result;
                value = fromJust(maybe);
              }
            };
          };
        };
      };
    };
  };
})(PS["Data.Unfoldable1"] = PS["Data.Unfoldable1"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Data.Unfoldable1"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup_Traversable = PS["Data.Semigroup.Traversable"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Tuple = PS["Data.Tuple"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Prelude = PS["Prelude"];                 
  var Unfoldable1 = function (unfoldr1) {
      this.unfoldr1 = unfoldr1;
  };
  var unfoldr1 = function (dict) {
      return dict.unfoldr1;
  };
  var unfoldable1Array = new Unfoldable1($foreign.unfoldr1ArrayImpl(Data_Maybe.isNothing)(Data_Maybe.fromJust())(Data_Tuple.fst)(Data_Tuple.snd));
  exports["Unfoldable1"] = Unfoldable1;
  exports["unfoldr1"] = unfoldr1;
  exports["unfoldable1Array"] = unfoldable1Array;
})(PS["Data.Unfoldable1"] = PS["Data.Unfoldable1"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Data.Unfoldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable1 = PS["Data.Unfoldable1"];
  var Data_Unit = PS["Data.Unit"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Prelude = PS["Prelude"];                 
  var Unfoldable = function (Unfoldable10, unfoldr) {
      this.Unfoldable10 = Unfoldable10;
      this.unfoldr = unfoldr;
  };
  var unfoldr = function (dict) {
      return dict.unfoldr;
  };
  var unfoldableArray = new Unfoldable(function () {
      return Data_Unfoldable1.unfoldable1Array;
  }, $foreign.unfoldrArrayImpl(Data_Maybe.isNothing)(Data_Maybe.fromJust())(Data_Tuple.fst)(Data_Tuple.snd));
  exports["Unfoldable"] = Unfoldable;
  exports["unfoldr"] = unfoldr;
  exports["unfoldableArray"] = unfoldableArray;
})(PS["Data.Unfoldable"] = PS["Data.Unfoldable"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad = PS["Control.Monad"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_FoldableWithIndex = PS["Data.FoldableWithIndex"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_FunctorWithIndex = PS["Data.FunctorWithIndex"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semigroup_Foldable = PS["Data.Semigroup.Foldable"];
  var Data_Semigroup_Traversable = PS["Data.Semigroup.Traversable"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_TraversableWithIndex = PS["Data.TraversableWithIndex"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_Unfoldable1 = PS["Data.Unfoldable1"];
  var Prelude = PS["Prelude"];                 
  var Nil = (function () {
      function Nil() {

      };
      Nil.value = new Nil();
      return Nil;
  })();
  var Cons = (function () {
      function Cons(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Cons.create = function (value0) {
          return function (value1) {
              return new Cons(value0, value1);
          };
      };
      return Cons;
  })();
  var foldableList = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return Data_Foldable.foldl(foldableList)(function (acc) {
              return function ($174) {
                  return Data_Semigroup.append(dictMonoid.Semigroup0())(acc)(f($174));
              };
          })(Data_Monoid.mempty(dictMonoid));
      };
  }, function (f) {
      var go = function ($copy_b) {
          return function ($copy_v) {
              var $tco_var_b = $copy_b;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(b, v) {
                  if (v instanceof Nil) {
                      $tco_done = true;
                      return b;
                  };
                  if (v instanceof Cons) {
                      $tco_var_b = f(b)(v.value0);
                      $copy_v = v.value1;
                      return;
                  };
                  throw new Error("Failed pattern match at Data.List.Types line 81, column 12 - line 83, column 30: " + [ v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_b, $copy_v);
              };
              return $tco_result;
          };
      };
      return go;
  }, function (f) {
      return function (b) {
          var rev = Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value);
          return function ($175) {
              return Data_Foldable.foldl(foldableList)(Data_Function.flip(f))(b)(rev($175));
          };
      };
  });
  var functorList = new Data_Functor.Functor(function (f) {
      return Data_Foldable.foldr(foldableList)(function (x) {
          return function (acc) {
              return new Cons(f(x), acc);
          };
      })(Nil.value);
  });
  var semigroupList = new Data_Semigroup.Semigroup(function (xs) {
      return function (ys) {
          return Data_Foldable.foldr(foldableList)(Cons.create)(ys)(xs);
      };
  });
  var applyList = new Control_Apply.Apply(function () {
      return functorList;
  }, function (v) {
      return function (v1) {
          if (v instanceof Nil) {
              return Nil.value;
          };
          if (v instanceof Cons) {
              return Data_Semigroup.append(semigroupList)(Data_Functor.map(functorList)(v.value0)(v1))(Control_Apply.apply(applyList)(v.value1)(v1));
          };
          throw new Error("Failed pattern match at Data.List.Types line 127, column 1 - line 127, column 33: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var applicativeList = new Control_Applicative.Applicative(function () {
      return applyList;
  }, function (a) {
      return new Cons(a, Nil.value);
  });
  exports["Nil"] = Nil;
  exports["Cons"] = Cons;
  exports["semigroupList"] = semigroupList;
  exports["functorList"] = functorList;
  exports["foldableList"] = foldableList;
  exports["applyList"] = applyList;
  exports["applicativeList"] = applicativeList;
})(PS["Data.List.Types"] = PS["Data.List.Types"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_FunctorWithIndex = PS["Data.FunctorWithIndex"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];                                                   
  var uncons = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just({
              head: v.value0,
              tail: v.value1
          });
      };
      throw new Error("Failed pattern match at Data.List line 259, column 1 - line 259, column 66: " + [ v.constructor.name ]);
  };
  var toUnfoldable = function (dictUnfoldable) {
      return Data_Unfoldable.unfoldr(dictUnfoldable)(function (xs) {
          return Data_Functor.map(Data_Maybe.functorMaybe)(function (rec) {
              return new Data_Tuple.Tuple(rec.head, rec.tail);
          })(uncons(xs));
      });
  };
  var tail = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just(v.value1);
      };
      throw new Error("Failed pattern match at Data.List line 245, column 1 - line 245, column 43: " + [ v.constructor.name ]);
  };
  var reverse = (function () {
      var go = function ($copy_acc) {
          return function ($copy_v) {
              var $tco_var_acc = $copy_acc;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(acc, v) {
                  if (v instanceof Data_List_Types.Nil) {
                      $tco_done = true;
                      return acc;
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      $tco_var_acc = new Data_List_Types.Cons(v.value0, acc);
                      $copy_v = v.value1;
                      return;
                  };
                  throw new Error("Failed pattern match at Data.List line 368, column 3 - line 368, column 19: " + [ acc.constructor.name, v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_acc, $copy_v);
              };
              return $tco_result;
          };
      };
      return go(Data_List_Types.Nil.value);
  })();
  var zipWith = function (f) {
      return function (xs) {
          return function (ys) {
              var go = function ($copy_v) {
                  return function ($copy_v1) {
                      return function ($copy_acc) {
                          var $tco_var_v = $copy_v;
                          var $tco_var_v1 = $copy_v1;
                          var $tco_done = false;
                          var $tco_result;
                          function $tco_loop(v, v1, acc) {
                              if (v instanceof Data_List_Types.Nil) {
                                  $tco_done = true;
                                  return acc;
                              };
                              if (v1 instanceof Data_List_Types.Nil) {
                                  $tco_done = true;
                                  return acc;
                              };
                              if (v instanceof Data_List_Types.Cons && v1 instanceof Data_List_Types.Cons) {
                                  $tco_var_v = v.value1;
                                  $tco_var_v1 = v1.value1;
                                  $copy_acc = new Data_List_Types.Cons(f(v.value0)(v1.value0), acc);
                                  return;
                              };
                              throw new Error("Failed pattern match at Data.List line 718, column 3 - line 718, column 21: " + [ v.constructor.name, v1.constructor.name, acc.constructor.name ]);
                          };
                          while (!$tco_done) {
                              $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_acc);
                          };
                          return $tco_result;
                      };
                  };
              };
              return reverse(go(xs)(ys)(Data_List_Types.Nil.value));
          };
      };
  };
  var $$null = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return true;
      };
      return false;
  };
  var head = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just(v.value0);
      };
      throw new Error("Failed pattern match at Data.List line 230, column 1 - line 230, column 22: " + [ v.constructor.name ]);
  };
  var fromFoldable = function (dictFoldable) {
      return Data_Foldable.foldr(dictFoldable)(Data_List_Types.Cons.create)(Data_List_Types.Nil.value);
  };
  exports["toUnfoldable"] = toUnfoldable;
  exports["fromFoldable"] = fromFoldable;
  exports["null"] = $$null;
  exports["head"] = head;
  exports["tail"] = tail;
  exports["uncons"] = uncons;
  exports["reverse"] = reverse;
  exports["zipWith"] = zipWith;
})(PS["Data.List"] = PS["Data.List"] || {});
(function(exports) {
    "use strict";

  exports.split = function (sep) {
    return function (s) {
      return s.split(sep);
    };
  };
})(PS["Data.String.Common"] = PS["Data.String.Common"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Data.String.Common"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_String_Pattern = PS["Data.String.Pattern"];
  var Prelude = PS["Prelude"];
  exports["split"] = $foreign.split;
})(PS["Data.String.Common"] = PS["Data.String.Common"] || {});
(function(exports) {
    "use strict";

  exports.unsafeToForeign = function (value) {
    return value;
  };
})(PS["Foreign"] = PS["Foreign"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Foreign"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Except = PS["Control.Monad.Except"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Either = PS["Data.Either"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Int = PS["Data.Int"];
  var Data_List_NonEmpty = PS["Data.List.NonEmpty"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_String_CodeUnits = PS["Data.String.CodeUnits"];
  var Prelude = PS["Prelude"];
  exports["unsafeToForeign"] = $foreign.unsafeToForeign;
})(PS["Foreign"] = PS["Foreign"] || {});
(function(exports) {
  /* globals exports, JSON */
  "use strict";

  exports.unsafeStringify = function (x) {
    return JSON.stringify(x);
  };
})(PS["Global.Unsafe"] = PS["Global.Unsafe"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Global.Unsafe"];
  exports["unsafeStringify"] = $foreign.unsafeStringify;
})(PS["Global.Unsafe"] = PS["Global.Unsafe"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Type_Data_Boolean = PS["Type.Data.Boolean"];
  var Type_Data_Symbol = PS["Type.Data.Symbol"];
  var Type_Equality = PS["Type.Equality"];
  var RLProxy = (function () {
      function RLProxy() {

      };
      RLProxy.value = new RLProxy();
      return RLProxy;
  })();
  exports["RLProxy"] = RLProxy;
})(PS["Type.Row"] = PS["Type.Row"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Data_Eq = PS["Data.Eq"];
  var Data_Function_Uncurried = PS["Data.Function.Uncurried"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Symbol = PS["Data.Symbol"];
  var Prelude = PS["Prelude"];
  var Record_Unsafe = PS["Record.Unsafe"];
  var Record_Unsafe_Union = PS["Record.Unsafe.Union"];
  var Type_Row = PS["Type.Row"];
  var Unsafe_Coerce = PS["Unsafe.Coerce"];
  var get = function (dictIsSymbol) {
      return function (dictCons) {
          return function (l) {
              return function (r) {
                  return Record_Unsafe.unsafeGet(Data_Symbol.reflectSymbol(dictIsSymbol)(l))(r);
              };
          };
      };
  };
  exports["get"] = get;
})(PS["Record"] = PS["Record"] || {});
(function(exports) {
    "use strict";

  exports.copyRecord = function(rec) {
    var copy = {};
    for (var key in rec) {
      if ({}.hasOwnProperty.call(rec, key)) {
        copy[key] = rec[key];
      }
    }
    return copy;
  };

  exports.unsafeInsert = function(l) {
    return function(a) {
      return function(rec) {
        rec[l] = a;
        return rec;
      };
    };
  };
})(PS["Record.Builder"] = PS["Record.Builder"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Record.Builder"];
  var Control_Category = PS["Control.Category"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function_Uncurried = PS["Data.Function.Uncurried"];
  var Data_Symbol = PS["Data.Symbol"];
  var Prelude = PS["Prelude"];
  var Record_Unsafe_Union = PS["Record.Unsafe.Union"];
  var Type_Row = PS["Type.Row"];
  var Unsafe_Coerce = PS["Unsafe.Coerce"];
  var semigroupoidBuilder = Control_Semigroupoid.semigroupoidFn;
  var insert = function (dictCons) {
      return function (dictLacks) {
          return function (dictIsSymbol) {
              return function (l) {
                  return function (a) {
                      return function (r1) {
                          return $foreign.unsafeInsert(Data_Symbol.reflectSymbol(dictIsSymbol)(l))(a)(r1);
                      };
                  };
              };
          };
      };
  };
  var categoryBuilder = Control_Category.categoryFn;
  var build = function (v) {
      return function (r1) {
          return v($foreign.copyRecord(r1));
      };
  };
  exports["build"] = build;
  exports["insert"] = insert;
  exports["semigroupoidBuilder"] = semigroupoidBuilder;
  exports["categoryBuilder"] = categoryBuilder;
})(PS["Record.Builder"] = PS["Record.Builder"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var $foreign = PS["Simple.JSON"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Monad_Except = PS["Control.Monad.Except"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Either = PS["Data.Either"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Identity = PS["Data.Identity"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Nullable = PS["Data.Nullable"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Symbol = PS["Data.Symbol"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Variant = PS["Data.Variant"];
  var Effect_Exception = PS["Effect.Exception"];
  var Effect_Uncurried = PS["Effect.Uncurried"];
  var Effect_Unsafe = PS["Effect.Unsafe"];
  var Foreign = PS["Foreign"];
  var Foreign_Index = PS["Foreign.Index"];
  var Foreign_Object = PS["Foreign.Object"];
  var Global_Unsafe = PS["Global.Unsafe"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Prelude = PS["Prelude"];
  var Record = PS["Record"];
  var Record_Builder = PS["Record.Builder"];
  var Type_Prelude = PS["Type.Prelude"];
  var Type_Row = PS["Type.Row"];
  var WriteForeign = function (writeImpl) {
      this.writeImpl = writeImpl;
  };
  var WriteForeignFields = function (writeImplFields) {
      this.writeImplFields = writeImplFields;
  };
  var writeImplFields = function (dict) {
      return dict.writeImplFields;
  };
  var writeImpl = function (dict) {
      return dict.writeImpl;
  };
  var writeJSON = function (dictWriteForeign) {
      return function ($85) {
          return Global_Unsafe.unsafeStringify(writeImpl(dictWriteForeign)($85));
      };
  };
  var writeForeignInt = new WriteForeign(Foreign.unsafeToForeign); 
  var writeForeignBoolean = new WriteForeign(Foreign.unsafeToForeign);
  var writeForeignArray = function (dictWriteForeign) {
      return new WriteForeign(function (xs) {
          return Foreign.unsafeToForeign(Data_Functor.map(Data_Functor.functorArray)(writeImpl(dictWriteForeign))(xs));
      });
  };
  var recordWriteForeign = function (dictRowToList) {
      return function (dictWriteForeignFields) {
          return new WriteForeign(function (rec) {
              var steps = writeImplFields(dictWriteForeignFields)(Type_Row.RLProxy.value)(rec);
              return Foreign.unsafeToForeign(Record_Builder.build(steps)({}));
          });
      };
  }; 
  var nilWriteForeignFields = new WriteForeignFields(function (v) {
      return function (v1) {
          return Control_Category.identity(Record_Builder.categoryBuilder);
      };
  });
  var consWriteForeignFields = function (dictIsSymbol) {
      return function (dictWriteForeign) {
          return function (dictWriteForeignFields) {
              return function (dictCons) {
                  return function (dictLacks) {
                      return function (dictCons1) {
                          return new WriteForeignFields(function (v) {
                              return function (rec) {
                                  var rest = writeImplFields(dictWriteForeignFields)(Type_Row.RLProxy.value)(rec);
                                  var value = writeImpl(dictWriteForeign)(Record.get(dictIsSymbol)(dictCons)(Data_Symbol.SProxy.value)(rec));
                                  var result = Control_Semigroupoid.compose(Record_Builder.semigroupoidBuilder)(Record_Builder.insert(dictCons1)(dictLacks)(dictIsSymbol)(Data_Symbol.SProxy.value)(value))(rest);
                                  return result;
                              };
                          });
                      };
                  };
              };
          };
      };
  };
  exports["writeJSON"] = writeJSON;
  exports["WriteForeign"] = WriteForeign;
  exports["writeImpl"] = writeImpl;
  exports["WriteForeignFields"] = WriteForeignFields;
  exports["writeImplFields"] = writeImplFields;
  exports["writeForeignInt"] = writeForeignInt;
  exports["writeForeignBoolean"] = writeForeignBoolean;
  exports["writeForeignArray"] = writeForeignArray;
  exports["recordWriteForeign"] = recordWriteForeign;
  exports["consWriteForeignFields"] = consWriteForeignFields;
  exports["nilWriteForeignFields"] = nilWriteForeignFields;
})(PS["Simple.JSON"] = PS["Simple.JSON"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Int = PS["Data.Int"];
  var Data_List = PS["Data.List"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_String = PS["Data.String"];
  var Data_String_Common = PS["Data.String.Common"];
  var Data_String_Pattern = PS["Data.String.Pattern"];
  var Data_Symbol = PS["Data.Symbol"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Prelude = PS["Prelude"];
  var Simple_JSON = PS["Simple.JSON"];                 
  var transfa = function (v) {
      return {
          allocV: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.getAllocV),
          maxiV: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.getMaxiV),
          needV: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.getNeedV),
          testAllocV: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.getTestAllocV),
          canAlloc: v.getCanAlloc
      };
  };
  var transf = function (v) {
      return {
          allocM: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(Data_Functor.map(Data_List_Types.functorList)(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray))(v.getAllocM)),
          maxiM: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(Data_Functor.map(Data_List_Types.functorList)(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray))(v.getMaxiM)),
          availV: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.getAvailV),
          procStat: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(Data_Functor.map(Data_List_Types.functorList)(transfa)(v.getProcStat)),
          isSafe: v.getIsSafe
      };
  };
  var readIntVec = function ($51) {
      return Data_Functor.map(Data_List_Types.functorList)(Data_Maybe.fromMaybe(0))(Data_List.fromFoldable(Data_Foldable.foldableArray)(Data_Functor.map(Data_Functor.functorArray)(Data_Int.fromString)(Data_String_Common.split(" ")($51))));
  };
  var readIntMat = function ($52) {
      return Data_List.fromFoldable(Data_Foldable.foldableArray)(Data_Functor.map(Data_Functor.functorArray)(readIntVec)(Data_String_Common.split(" ")($52)));
  };
  var maxi = "0 6 5 6\x0a1 9 4 2\x0a1 3 5 6\x0a1 7 5 0";
  var handleProc = function (v) {
      if (v.alloc instanceof Data_List_Types.Nil && v.maxi instanceof Data_List_Types.Nil) {
          return {
              isSafe: false,
              procStats: Data_List_Types.Nil.value,
              ret: v
          };
      };
      if (v.alloc instanceof Data_List_Types.Cons && v.maxi instanceof Data_List_Types.Cons) {
          var needV = Data_List.zipWith(Data_Ring.sub(Data_Ring.ringInt))(v.maxi.value0)(v.alloc.value0);
          var testAllocV = Data_List.zipWith(Data_Ring.sub(Data_Ring.ringInt))(v.avail)(needV);
          var canAlloc = Data_Foldable.all(Data_List_Types.foldableList)(Data_HeytingAlgebra.heytingAlgebraBoolean)(function (nn) {
              return nn >= 0;
          })(testAllocV);
          var x = {
              getAllocV: v.alloc.value0,
              getMaxiV: v.maxi.value0,
              getNeedV: needV,
              getTestAllocV: testAllocV,
              getCanAlloc: canAlloc
          };
          if (canAlloc) {
              var availV$prime = Data_List.zipWith(Data_Semiring.add(Data_Semiring.semiringInt))(v.alloc.value0)(v.avail);
              var v1 = handleProc({
                  alloc: v.alloc.value1,
                  maxi: v.maxi.value1,
                  avail: availV$prime
              });
              return {
                  isSafe: true,
                  procStats: new Data_List_Types.Cons(x, v1.procStats),
                  ret: v1.ret
              };
          };
          var v1 = handleProc({
              alloc: v.alloc.value1,
              maxi: v.maxi.value1,
              avail: v.avail
          });
          return {
              isSafe: v1.isSafe,
              procStats: new Data_List_Types.Cons(x, v1.procStats),
              ret: {
                  alloc: new Data_List_Types.Cons(v.alloc.value0, v1.ret.alloc),
                  maxi: new Data_List_Types.Cons(v.maxi.value0, v1.ret.maxi),
                  avail: v1.ret.avail
              }
          };
      };
      return {
          isSafe: false,
          procStats: Data_List_Types.Nil.value,
          ret: v
      };
  };
  var handleConstr = function (v) {
      var v1 = handleProc(v);
      var x = {
          getAllocM: v.alloc,
          getMaxiM: v.maxi,
          getAvailV: v.avail,
          getProcStat: v1.procStats,
          getIsSafe: v1.isSafe
      };
      var $43 = v1.isSafe && !Data_List["null"](v1.ret.alloc);
      if ($43) {
          return Data_List_Types.Cons.create(x)(handleConstr(v1.ret));
      };
      return Control_Applicative.pure(Data_List_Types.applicativeList)(x);
  };
  var banker = function (allocM) {
      return function (maxiM) {
          return function (availV) {
              return handleConstr({
                  alloc: readIntMat(allocM),
                  maxi: readIntMat(maxiM),
                  avail: readIntVec(availV)
              });
          };
      };
  };
  var main = function (alloc1) {
      return function (maxi1) {
          return function (avail1) {
              return Simple_JSON.writeJSON(Simple_JSON.writeForeignArray(Simple_JSON.recordWriteForeign()(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "allocM";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt)))(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "availV";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt))(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "isSafe";
              }))(Simple_JSON.writeForeignBoolean)(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "maxiM";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt)))(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "procStat";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.recordWriteForeign()(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "allocV";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt))(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "canAlloc";
              }))(Simple_JSON.writeForeignBoolean)(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "maxiV";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt))(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "needV";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt))(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "testAllocV";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt))(Simple_JSON.nilWriteForeignFields)()()())()()())()()())()()())()()())))(Simple_JSON.nilWriteForeignFields)()()())()()())()()())()()())()()())))(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(Data_Functor.map(Data_List_Types.functorList)(transf)(banker(alloc1)(maxi1)(avail1))));
          };
      };
  };
  var avail = "1 5 2 0";
  var alloc = "0 0 1 4\x0a1 4 3 2\x0a1 3 5 4\x0a1 0 0 0";
  exports["main"] = main;
  exports["alloc"] = alloc;
  exports["maxi"] = maxi;
  exports["avail"] = avail;
})(PS["Banker"] = PS["Banker"] || {});
(function(exports) {
  // Generated by purs version 0.12.1
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Int = PS["Data.Int"];
  var Data_List = PS["Data.List"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_String = PS["Data.String"];
  var Data_String_Common = PS["Data.String.Common"];
  var Data_String_Pattern = PS["Data.String.Pattern"];
  var Data_Symbol = PS["Data.Symbol"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Prelude = PS["Prelude"];
  var Simple_JSON = PS["Simple.JSON"];                 
  var transfa = function (v) {
      return {
          allocV: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.getAllocV),
          maxiV: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.getMaxiV),
          needV: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.getNeedV),
          testAllocV: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.getTestAllocV),
          canAlloc: v.getCanAlloc
      };
  };
  var transf = function (v) {
      return {
          allocM: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(Data_Functor.map(Data_List_Types.functorList)(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray))(v.getAllocM)),
          maxiM: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(Data_Functor.map(Data_List_Types.functorList)(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray))(v.getMaxiM)),
          availV: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.getAvailV),
          procStat: Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(Data_Functor.map(Data_List_Types.functorList)(transfa)(v.getProcStat)),
          isSafe: v.getIsSafe
      };
  };
  var readIntVec = function ($51) {
      return Data_Functor.map(Data_List_Types.functorList)(Data_Maybe.fromMaybe(0))(Data_List.fromFoldable(Data_Foldable.foldableArray)(Data_Functor.map(Data_Functor.functorArray)(Data_Int.fromString)(Data_String_Common.split(" ")($51))));
  };
  var readIntMat = function ($52) {
      return Data_List.fromFoldable(Data_Foldable.foldableArray)(Data_Functor.map(Data_Functor.functorArray)(readIntVec)(Data_String_Common.split(" ")($52)));
  };
  var maxi = "0 6 5 6\x0a1 9 4 2\x0a1 3 5 6\x0a1 7 5 0";
  var handleProc = function (v) {
      if (v.alloc instanceof Data_List_Types.Nil && v.maxi instanceof Data_List_Types.Nil) {
          return {
              isSafe: false,
              procStats: Data_List_Types.Nil.value,
              ret: v
          };
      };
      if (v.alloc instanceof Data_List_Types.Cons && v.maxi instanceof Data_List_Types.Cons) {
          var needV = Data_List.zipWith(Data_Ring.sub(Data_Ring.ringInt))(v.maxi.value0)(v.alloc.value0);
          var testAllocV = Data_List.zipWith(Data_Ring.sub(Data_Ring.ringInt))(v.avail)(needV);
          var canAlloc = Data_Foldable.all(Data_List_Types.foldableList)(Data_HeytingAlgebra.heytingAlgebraBoolean)(function (nn) {
              return nn >= 0;
          })(testAllocV);
          var x = {
              getAllocV: v.alloc.value0,
              getMaxiV: v.maxi.value0,
              getNeedV: needV,
              getTestAllocV: testAllocV,
              getCanAlloc: canAlloc
          };
          if (canAlloc) {
              var availV$prime = Data_List.zipWith(Data_Semiring.add(Data_Semiring.semiringInt))(v.alloc.value0)(v.avail);
              var v1 = handleProc({
                  alloc: v.alloc.value1,
                  maxi: v.maxi.value1,
                  avail: availV$prime
              });
              return {
                  isSafe: true,
                  procStats: new Data_List_Types.Cons(x, v1.procStats),
                  ret: v1.ret
              };
          };
          var v1 = handleProc({
              alloc: v.alloc.value1,
              maxi: v.maxi.value1,
              avail: v.avail
          });
          return {
              isSafe: v1.isSafe,
              procStats: new Data_List_Types.Cons(x, v1.procStats),
              ret: {
                  alloc: new Data_List_Types.Cons(v.alloc.value0, v1.ret.alloc),
                  maxi: new Data_List_Types.Cons(v.maxi.value0, v1.ret.maxi),
                  avail: v1.ret.avail
              }
          };
      };
      return {
          isSafe: false,
          procStats: Data_List_Types.Nil.value,
          ret: v
      };
  };
  var handleConstr = function (v) {
      var v1 = handleProc(v);
      var x = {
          getAllocM: v.alloc,
          getMaxiM: v.maxi,
          getAvailV: v.avail,
          getProcStat: v1.procStats,
          getIsSafe: v1.isSafe
      };
      var $43 = v1.isSafe && !Data_List["null"](v1.ret.alloc);
      if ($43) {
          return Data_List_Types.Cons.create(x)(handleConstr(v1.ret));
      };
      return Control_Applicative.pure(Data_List_Types.applicativeList)(x);
  };
  var banker = function (allocM) {
      return function (maxiM) {
          return function (availV) {
              return handleConstr({
                  alloc: readIntMat(allocM),
                  maxi: readIntMat(maxiM),
                  avail: readIntVec(availV)
              });
          };
      };
  };
  var main = function (alloc1) {
      return function (maxi1) {
          return function (avail1) {
              return Simple_JSON.writeJSON(Simple_JSON.writeForeignArray(Simple_JSON.recordWriteForeign()(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "allocM";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt)))(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "availV";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt))(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "isSafe";
              }))(Simple_JSON.writeForeignBoolean)(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "maxiM";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt)))(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "procStat";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.recordWriteForeign()(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "allocV";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt))(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "canAlloc";
              }))(Simple_JSON.writeForeignBoolean)(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "maxiV";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt))(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "needV";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt))(Simple_JSON.consWriteForeignFields(new Data_Symbol.IsSymbol(function () {
                  return "testAllocV";
              }))(Simple_JSON.writeForeignArray(Simple_JSON.writeForeignInt))(Simple_JSON.nilWriteForeignFields)()()())()()())()()())()()())()()())))(Simple_JSON.nilWriteForeignFields)()()())()()())()()())()()())()()())))(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(Data_Functor.map(Data_List_Types.functorList)(transf)(banker(alloc1)(maxi1)(avail1))));
          };
      };
  };
  var avail = "1 5 2 0";
  var alloc = "0 0 1 4\x0a1 4 3 2\x0a1 3 5 4\x0a1 0 0 0";
  exports["main"] = main;
  exports["alloc"] = alloc;
  exports["maxi"] = maxi;
  exports["avail"] = avail;
})(PS["Main"] = PS["Main"] || {});